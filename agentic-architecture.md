# Agentic Architecture

### Salient Features

1. System Prompt:
    - Defines the overall goal for the agent.
    - Specifies when to use certain tools and how to interpret their output.
    - Provides instructions on generating input for tools.
2. Tools:
    - Represent arbitrary functions (denoted by $T$), which map a string input to a optional string-cast-able output.
    - Tool calls ($T$ and $T'$) receive input generated by the agent and return outputs that are (usually) interpreted
      by the agent.
    - Tool-specific Input: the agent is able to generate tool inputs ($gti$, $gti'$) that target specific tools.
3. Chat:
    - Handles user input $ui$ and emits agent output $ao$ using optional tool-calling processes
    - The symbol chat* signifies self-chat, where tool output is used as a message and interpreted by the agent.
4. Agent Output $(A(ui))$:
    - Represents the final output based on the user’s input $ui$, including processed responses through tools and chat*
      functions.

### Chat Flow

1. Initial Input $ui$:
    - The user’s input $ui$ initiates a chat process $chat(ui)$.
    - First Layer of Tool Interaction:
        - Either the agent directly responds, making $chat(ui) = A(ui)$, or…
        - The agent generates tool input = $gti(ui)$ and applies the tool function $T(gti(ui))$ to produce a tool
          output $to$.
        - This output either:
            - Loops back into another chat* stage to be interpreted by the agent $chat*(to)$, or…
            - Outputs directly as agent output $to = A(ui)$.
2. Recursive Tool Processing:
    - If further processing is needed, a new tool-specific input $gti'$ is created from the previous stage’s result.
    - If the agent uses a different tool, $T'$, then $T'$ acts on $gti'$, feeding into subsequent $chat*$ stages or
      directly
      outputting as $to = T'(gti')$.
3. Multiple Cycles of Chat and Tool Use:
    - The cycle continues to produce tool outputs, each with an optional $chat*$ stage where intermediate results are
      re-interpreted by the agent, or instead returned directly to the user.
    - Tools can be called multiple times, such as when the agent generates another input $gti'_2$ for a tool it has
      already used $T'$.
4. Agent Output $A(ui)$:
    - After cycling through chat and tool functions, the final result is aggregated into $A(ui)$, representing the
      output
      based on user input after all interactions.

### Examples

- agent output $ao$
  $$A(u_i) = \text{chat}(u_i)$$
- tool output $to$
  $$A_t(u_i) = T(\text{gti}(u_i))$$
- agent interpretation of first tool output $ao$
  $$A_{ta}(u_i) = \text{chat}^*(T(\text{gti}(u_i)))$$
- direct output from second tool call $to$
  $$A_{tt'}(u_i) = T'(\text{gti}'(A_{ta}(u_i))) = T'(\text{gti}'(\text{chat}^*(T(\text{gti}(u_i)))))$$
- agent interpretation of second tool output $ao$
  $$A_{tt'a}(u_i) = \text{chat}^*(A_{tt'}(u_i)) = \text{chat}^*(T'(\text{gti}'(A_{ta}(u_i)))) = \text{chat}^*(T'(\text{gti}'(\text{chat}^*(T(\text{gti}(u_i))))))$$
- recursive tool call on intermediate result $to$
  $$A_{t(t')^2}(u_i) = T'(\text{gti}'(A_{tt'a}(u_i))) = \dots = T'(\text{gti}'(\text{chat}^*(T'(\text{gti}'(\text{chat}^*(T(\text{gti}(u_i))))))))$$
- final agent interpretation of recursive tool output $ao$
  $$A_{t(t')^2a}(u_i) = \text{chat}^*(A_{t(t')^2}(u_i)) = \dots = \text{chat}^*(T'(\text{gti}'(\text{chat}^*(T'(\text{gti}'(\text{chat}^*(T(\text{gti}(u_i)))))))))$$

# Recursive, Multi-Turn Interactions

In this extended framework, we incorporate two key assumptions:

1. Users can continue their chats with agents, allowing for multi-turn conversations.
2. Tool calls can also be agents, enabling recursive agent interactions where tools themselves have agent-like
   behaviors.

By integrating these assumptions, we develop an algebraic system to describe complex interactions between users, agents,
and tool-agents, which can be represented visually as a graph.

### Agent’s State and History

**Conversation $C$**: A sequence of interactions between the user and the agent
$$
C = \{(u_1, A(u_1)), (u_2, A(u_2 | h_1)), \dots, (u_n, A(u_n | h_{n-1}))\}
$$
where

- $u_i$ is the user’s input at turn $i$
- $A(u_i | h_{i-1})$ is the agent’s output based on $u_i$ and the conversation history $h_{i-1}$
- $h_{i}$ represents the conversation history up to turn $i$

**Conversation History $h_i$**: Accumulates all prior interactions.
$$
h_i = h_{i-1} + (u_i, A(u_i | h_{i-1}))
$$

**Agent Output with History**:
$$
A(u_i | h_{i-1}) = \text{Process}(u_i, h_{i-1})
$$

- The agent processes the current input in the context of the entire conversation.

**Multi-Turn Interaction Flow**

1. User Input:$u_i$
2. Agent Processes Input: Considers $u_i$  and $h_{i-1}$.
3. Tool Usage (Optional):
    - Agent may generate tool input $gti(u_i, h_{i-1})$.
    - Tool output is obtained and possibly fed back into the conversation.
4. Agent Output: $A(u_i | h_{i-1})$ is produced and added to the history.

### Tool-Agents

**Tool-Agent, $T_A$**: A tool that operates as an agent with its own system prompt, tools, and conversation history.
**Tool-Agent Interaction**:
$$
T_A(gti) = A_T(gti | h_T)
$$
where:

- $A_T$  is the agent function of the tool-agent.
- $h_T$  is the history of the tool-agent.

Recursive Agent Interactions

- Agent Calling a Tool-Agent:
    - The primary agent treats the tool-agent like a tool but interacts with it as with another agent.
    - Communication can be multi-turn between the agent and the tool-agent.

Example Flow

1. Primary Agent Generates Input: $gti$ for tool-agent $T_A$.
2. Tool-Agent Processes Input: $A_T(gti | h_T)$.
3. Tool-Agent May Use Its Own Tools or Tool-Agents: Potentially recursive.
4. Tool-Agent Returns Output: To the primary agent.
5. Primary Agent Continues Processing: May incorporate the output into further tool calls or produce the final output.

## Interaction Algebra

### Symbols and Notations

- Agents:
    - Primary agent: $A$
    - Tool-agent: $A_T$
- User Inputs: $u_i$
- Agent Outputs: $A(u_i | h_{i-1})$
- Tool Inputs:
    - Generated by agents: $gti$
    - With history: $gti(u_i, h_{i-1})$
- Tool Functions:
    - Standard tools: $T$
    - Tool-agents: $T_A$

### Operations

1. Agent Processing:
   $$
   A(u_i | h_{i-1}) = \text{chat}(u_i, h_{i-1})
   $$
2. Tool Call by Agent:

- Tool call:  $$T \rightarrow T(\text{gti})$$
- or Tool-agent call:  $$\text{or } T_A \rightarrow A_T(\text{gti} \mid h_T)$$

3. Agent Interpreting Tool Output:
   $$
   \text{chat}^*(\text{tool output}, h{i-1})
   $$
4. Updating Histories:

- User-agent history:
  $$h_i = h_{i-1} + (u_i, A(u_i | h_{i-1}))$$
- Agent-tool-agent history:
  $$h_T = h_T + (\text{agent\_input}, \text{tool-agent\_output})$$

### Algebraic Representation

- Single Interaction:
  $$
  A(u_i | h_{i-1}) = \text{chat}\left(u_i, h_{i-1} + \sum_{k=1}^{n} \text{chat}^*\left(T_k\left(gti_k\right), h_{i-1}\right)\right)
  $$
  where $T_k$ could be a tool or tool-agent.

- Recursive Tool-Agent Calls:
  $$
  A(u_i | h_{i-1}) = \text{chat}\left(u_i, h_{i-1} + \text{chat}^*\left(A_T\left(gti_T | h_T\right), h_{i-1}\right)\right)
  $$

- Generalized Interaction:
  $$
  A(u_i | h_{i-1}) = \text{Process}\left(u_i, h_{i-1}, \{T_j\}, \{gti_j\}\right)
  $$
  where $\{T_j\}$ and $\{gti_j\}$ are sets of tools/tool-agents and their inputs used during processing.

### Visual Representation as a Graph

Nodes:

- User inputs $u_i$
- Agent outputs $A(u_i | h_{i-1})$
- Tool outputs $T(gti)$
- Tool-agents $A_T$ and their outputs

Edges:

- Directed edges represent the flow of information:
    - From user input to agent processing.
    - From agent to tool/tool-agent.
    - From tool/tool-agent back to agent.
    - Between consecutive turns in the conversation.

Diagram Components:

1. User-Agent Interaction:
    - Arrows from $u_i$ to $A$.
    - Arrows from $A$ to $A(u_i | h_{i-1})$.
2. Agent-Tool Interaction:
    - Arrows from $A$ to $T$  or $A_T$ labeled with  $gti$.
    - Arrows from $T$ or $A_T$  back to $A$ with tool outputs.
3. Recursive Interactions:
    - Tool-agents may have their own subgraphs representing their internal processing.
4. Conversation History:
    - Dashed lines or stacked nodes indicating the accumulation of history.

## Examples

#### Example Diagram

Nodes:

- $u_1$
- $A(u_1 | h_0)$
- $T$
- $A_T$
- $A(u_2 | h_1)$

Edges:

- $u_1 \rightarrow A$
- $A \rightarrow T$ (with $gti$)
- $T \rightarrow A$ (with tool output)
- $A \rightarrow A_T$ (if tool-agent)
- $A_T \rightarrow A$
- $A \rightarrow A(u_1 | h_0)$
- $Au_1 | h_0) \rightarrow h_1$
- $u_2 \rightarrow A$

#### Conversation Flow

1. Turn 1:
    - User input: $u_1$
    - Agent processes $u_1$, uses tool $T$.
    - $A(u_1 | h_0) = \text{chat}^*\left(T\left(gti(u_1)\right), h_0\right)$
    - Output added to history: $h_1 = h_0 + (u_1, A(u_1 | h_0))$
2. Turn 2:
    - User input: $u_2$
    - Agent processes $u_2$ considering $h_1$.
    - Agent calls tool-agent $A_T$.
    - $A(u_2 | h_1) = \text{chat}^*\left(A_T\left(gti_T(u_2) | h_T\right), h_1\right)$
    - Update histories: $h_2$ and $h_T$

#### Algebraic Representation

1. Turn 1:
    - $A(u_1 | h_0) = \text{chat}^*\left(T\left(gti(u_1)\right), h_0\right)$

2. Turn 2:
    - $A(u_2 | h_1) = \text{chat}^*\left(A_T\left(gti_T(u_2) | h_T\right), h_1\right)$

3. Tool-Agent Interaction:

    - $A_T\left(gti_T(u_2) | h_T\right) = \text{Process}_T\left(gti_T(u_2), h_T\right)$

